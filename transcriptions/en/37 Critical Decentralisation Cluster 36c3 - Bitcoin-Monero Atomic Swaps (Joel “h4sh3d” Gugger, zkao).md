# Joel “h4sh3d” Gugger, zkao

_**Critical Decentralisation Cluster 36c3 - 3.8 Billion Users' Future: Email 3.0 (Sam Tuke)**_

[youtu.be/G-v6hDnzpds](https://youtu.be/G-v6hDnzpds)

_**Abstract**_

In this talk we propose an approach on bitcoin-monero atomic swap, its development state and open problems.

_**Transcription**_

_Diego:_ These guys are ready. These guys are ready, we're almost ready, everything’s almost ready. We're ready, see? It all came together in the end. So I would like to introduce h4sh3d and zkao. They're gonna come up here and talk about Bitcoin-Monero swaps. I'm gonna pass this off to the two of them. Do you guys want two mics or are you with this one? Oh, just you. Oh, they're gonna do atomic swaps on stage. They're gonna do an act. They're gonna… mm-hmm… I was gonna say something cool, but then I butchered it. So I'm just gonna pass off this mic to them, and let them tell you from here.

_zkao:_ Hello everybody. So at two years ago we were here sitting between the Monero and Bitcoin. We were sitting between the Monero n' and Bitcoin tables, and I was talking to Polto, and Polto suggested: “Why don't you try to work on BTC-Monero atomic swap?” And we started. We didn't think it was possible, but well after 2 years we have something more concrete, and we would like to talk about it.

So a lot of people got into Bitcoin because they thought it was like an anonymous currency. So like for example this tweet from 2011 from WikiLeaks: “WikiLeaks now accepts that anonymous Bitcoin donations on this address”. As we know Bitcoin is based on output and you can trace. So this is a Bitcoin transaction. These are two outputs, these are the UTXOs. And here this output get spent by on this transaction, and produces output that gets spent on this transaction, and it produces output. So you can link these three outputs together, so you can trace everything. So here's another example which is a little bit more interesting, because here you take one output, you split in two outputs, and then you merge them back into one output, which means like it's the same person.

So this address here and these are all the addresses that send money to it, and the size encodes the volume that pass through that those addresses. So you see these three big addresses, these are probably businesses like exchanges, and of course you can anonymize people if you can trace it back to such a big hub. So the Bitcoins cannot be easily tracked back to you, which was in WikiLeaks website, well not true at all.

So how do you avoid traceability? On Bitcoin you can't. But if you have a way to trustless swap Bitcoin to Monero, for example, then you can. So and it's very important that this has to be trustless, because otherwise you need identities, and it's like then you're not anonymous anymore.

So the basic idea of cross chain atomic swaps is that like for example here Bob has Bitcoin, Alice has Monero, and they either want this transaction to go through, like meaning Alice in the end ends up with Bitcoin, starts with Monero and ends up with Bitcoin, and Bob starts with Bitcoin and ends up with Monero. Both have to go through or none have to go through. This is the atomicity of the atomic swap.

So why Bitcoin-Monero? So Bitcoin is the real thing, but it's traceable. Monero is untraceable. So Bitcoin has a large market cap, people use it a little bit, and additionally, just like as a side note, is like many users are unable to move their coins. So if 10% of Satoshi coins would go into Monero, the market cap doubles already. So again like atomic swaps are trustless, there is no trusted party involved, so anonymous trades can happen.

So we are here presented today, because we started this project here, and there are some things that we didn't work out, for example we need a zero knowledge proof that we don't know how to do. And we would love to have help from the community. Additionally a few libraries got developed on this work, and it would be great to get community participation and community contribution to these libraries. With this I will pass to h4sh3d, and he's going to go through the protocol carefully.

_h4sh3d:_ Thank you. Hi everyone. So I will cover a bit in detail the protocol. But before starting let's talk about the scenario.

So here we have Alice that has some Monero, and she wants Bitcoin. Bob has Bitcoin and wants Moneroes. They already agree on the price and the quantity, and they want to trade, but they don't trust each other. And in the protocol we assume that one can be malicious.

So first I need a bit of notation and little math, and I promise it's very little, but it's the boring part, but the fun part will come just in a few seconds. So first we denote Bitcoin private key as bi and i can be either a or b for Alice and Bob. And we use capital B for the Bitcoin public key for Alice and for Bob. For the Monero keys we denote the private keys with small k, and small kv and ks for the private view key and the private spend keys. And we use capital K again for view and spend keys for the public keys.

So we can define an account with a pair of two public keys, and we can parse an account with the knowledge of the private view key, and we can spend from the accounts only if we have the knowledge of the private spend key. And for the protocol we defined partial keys or shares, and we denote a share for the spend key with a small a and small b for Alice and Bob. And we defined the full spend private key with just an addition mod l. And that is a parameter for the edward25519 curve.

And last slide on the boring parts, notation, when we say ksa, capital A, we mean that ksa is known by Alice, it's for the next graph, we use this big capital A and capital B for who knows what secrets. So now come now we can go through the protocol, and here is the fun part.

Here we assume that first, because they want a trade, they both completed the initialization and locking phases. I will go in detail about these two phases later, but now all the parameters are initialized, and found our locked and we can start the swap. So what's happening is Bob knows some secret, and he will share the secret to Alice. So we move one step. We do the transition in this state diagram, we do one transition with, we do the start and the knowledge of s is shared with Alice. And now at least I'll have all the prerequisites to do the buy action.

So by doing the buy action, the Bitcoin that have been locked are transferred to Alice on her Bitcoin wallet, and as a side effect of this transaction, this Bitcoin transaction, we on purpose we leak some information, and in that case is the knowledge ksa that was known by Alice was leaked during this transaction, and now ksa is known by Bob. And because Bob knows ksa and ksb, he can reconstruct the full ks key, private key. So we have the locked Monero, Bob has the knowledge of the full spend key, and he can get the Monero. So basically we just leak one part of the private key depending on the path in the protocol.

So that was a quick overview of the successful path of the protocol. I said before that the protocol is decoupled in three main phases. First is the initialization. In the initialization we will generate all the parameters that need to be specific and common to each party. And we will also in these phases generate the zero knowledge proof, I will talk about the proofs a bit later. And when this is done we can create the different transactions that will lock the fund. And when the funds are locked, we can start the swap. So after the lock is done we are in this state, and we can proceed to the swap. So in reality the swap phase is the smallest and simplest phase.

So first the protocol initialization. We generate the view and the spend partial private keys, each generate this private keys, and derive the associated partial public key. Each generator pair of Bitcoin keys, they compute the hash of the private spend shares, and Bob compute secret and also the hash of this secret. And then comes the zero knowledge proof, that I will talk about it later, and they exchange the private view key, because they want to have the view of what's going on the Monero blockchain. They share the spend public keys, so with this information they can have the locking address for the Monero parts. They both exchange their Bitcoin public keys, and they share the hashes and the zero knowledge proofs. And after sharing this information each verify the zero knowledge of the other party. And if everything passes the validation we are good to go for the lock phase.

So the locking phase for the Bitcoin side requires two transactions. If you are familiar with a payment channel construction, it's a like kind of standard construction. And here we have a first Bitcoin transaction that's lock Bob's Bitcoin, and have at least one UTXO that has this script, and the script will allow for the buy action or allow the refund, if the swap is canceled. And if the refund is used this transaction will again allow two different paths. The first is the refund is completed, so each get their money back minus the fees on each chain, and the third, the forth path, sorry, the third path is created as an incentive mechanism to force this one. In that case Alice will get the Bitcoin without revealing any information. Here we can see that h_a, so the hash of one of the secrets, is leaked during the transaction, because we will need to reveal the secret that will correspond to the h_a. Here we will leak the secret from Bob, but here we don't leak, we just wait and we can get the Bitcoin out. So we did that because we can have a deadlock if nobody acts here. I will talk about it a bit more later.

So that was the two Bitcoin transactions now we have one transaction for the Monero part, where we move Alice Monero into the address that corresponds to these two private keys, and this address is again generated in the initialization phase. So here we can see how Alice can buy the Bitcoin. She can sign with her key, she need the secret s that is generated from Bob, and she leaked the secret.

Here we can see how Bob can refund and then cancel the swap. We see that he has to sign, and he has to reveal his secret part. And here we see that Alice can claim the refund without revealing anything, but after some timelock. So if Bob doesn't react he will lose. So this force Bob to react when the refund is triggered.

And for the swap here it's basically the same as the graphic we had before. So we see the s secret that Alice needs to know to trigger the buy. She needs her own private secret, she needs the Bitcoin transaction, and this will consume and transfer the Bob's Bitcoin if she do the buy by revealing to Bob this information.

So what happen if Bob never shared this s parameter. After sometime in the first transaction here, after sometime this refund can be triggered. So if Bob never share the secret to Alice, and we are still in this state, the refund can be triggered. And with the refund Bob should directly spend the refund, or Alice will be able to claim it. Now what if Alice doesn't buy. Bob shares the secret, so Alice should be able to do the buy, but she doesn't do anything. Then Bob also after the first timelock can do the refund and directly spend a refund to get the Bitcoin back. And by doing that he will reveal the secret and then Alice can take her Monero back. And now if Bob does on refund again, we have the claim from Alice, that is the incentives to Bob do refund, and that's the full protocol.

Now the known limitations or open problems we have still is the zero knowledge proof part. So what we need to prove is that the secret we will reveal on chain is really related to the hash and to the public key we sent in the initialization phase. So we can show it like that. After this initialization what is exchange is the point on the curve that is used to get the Monero address, the two points are added to get the full address, and the hash that is used in the Bitcoin transaction. And it works because we want a relation between those two, we want two secrets that will end up to the hash, and that will end up to the to the point. So this is the zero knowledge proof that we need.

Thank you everyone for attending the talk. We are like really open to have any feedback or community contribution on this paper or the libraries. And if you wanna reach us, we also have a Petri net that represent the whole protocol, and you can play with it. We will also release a small video where the Petri net is a bit more explained. Here we put just like a partial view of the system with the graph. So yeah feel free to reach us and chat about it. I don't know if we have time for questions. Yeah we have time for questions, so any questions?

_Audience:_ Hi, thanks. Is it possible to see like once the transaction is done that on the Bitcoin side is it possible to see that I participated in this cross chain atomic swap?

_h4sh3d:_ So what you can analyze on the Bitcoin chain is you can see this script. If the swap go through directly you can see this script with this transaction, that will reveal the information. So that will be for sure in clear, and you can match everything that has this part. This will reveal an information about the Monero part, but this information is not enough to get anything, to do any relation to the Monero part. So here you can maybe assume that the person is not the same anymore in the Bitcoin part, but that's the only information you should be able to get.

_zkao:_ So this Petri nets like they really model the whole protocol execution, because it's a bit we could not make it simple enough to be able to display it here. But if you want to visit any possible path of the protocol, come to us and we're gonna play the Petri net, and you're gonna be very clear like every potential protocol the execution that can happen. So we did this with yesterday with the help of Statebox and we thank them for that. Ok, thank you.
