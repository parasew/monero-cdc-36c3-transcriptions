# Jan

_**Critical Decentralisation Cluster 36c3 - Projects Should Support Passwordless Login, FIDO2, WebAuthn**_

[youtu.be/upa7_mZWTXU](https://youtu.be/upa7_mZWTXU)

_**Abstract**_

A login form with user name and password is implemented quickly. But passwords don't scale from the user perspective and the new WebAuthentication standard is there to replace them. This presentation gives an introduction to WebAuthn and FIDO2, why to implement it, how to use it etc.

_**Transcription**_

_Diego:_ You came here for this presentation. You're like: “Diego get off the stage”, and I'm more than happy to. So I'm gonna hand this off to Jan who's going to take us through WebAuthn. WebAuthn? Guys there should be vowels there somewhere, but I'm not going to ask you to justify that. So go ahead and why don't you take us through this.

_Jan:_ All right, thank you. So I'm going to talk about passwords and the new web authentication thing. But first of all a short introduction to myself. My name is Jan, I'm a founder of Nitrokey. What we do is open source hardware made in Germany. We basically produce and develop use pkeys for data encryption or cryptographic key usages like HSMs, and of course two-factor authentication and passwordless authentication which I'm going to talk about today. But first of all a picture how it looks what we do is devices, so that you know what we are talking about. USB devices, use pkeys like this but not ordinary some device.

So why to use passwords? I guess everybody who has ever written any application or web service has introduced some at least if you have some user management or anything like that, some access control, you have introduced some passwords. They are easy to implement, everybody knows how they work. They work out of the box on any platform, on where your application or your web service is supported. So it's super easy thing. So why not to use them?

There are a few reasons. We all are aware that they are inherently insecure, at least it's hard to make them secure. So it's easy to use them insecurely, say you share easy to remember password among couple of services, but it's insecure. So what you are going to do to have a more secures, to have a longer passphrase individually for each service, which you can't remember then anymore, if you use more say ten services. So you need some way, or password manager, or something like this. So it can become very complicated quickly.

It doesn't scale, and you don't have any form of phishing protection, which, if it's a sweat, we can address by more modern methods like WebAuthn, and I'm going to talk about soon. And one thing I'm I want to highlight is convenience. So usually when we talk about security, making things more secure, it comes with the trade-off of usability. So often it's like: do you want to have something secure or easy to use? And I think here now we add a point, and in 2019 we are at a stage where we can have a solution which is more secure and more easy to use than before. And I think this has a in the long term can be a very effective, very huge leverage.

So after say kind of after passwords or an add-on to passwords or one-time passwords, which you can use with Google Authenticator, this is one of the most popular forms of using one-time passwords, it's supported by many of the large websites by today, you can have clients on every platform, you can have use p security keys, to use one-time passwords as well. The setup is or the architecture is based on a shared secret among the client and the server, so it's not super modern, also this standard is goes back say 15 years ago about, and how it works is basically it's a hash which is calculated over the time, and this shared secret so that then once a client locks in to a server, the client side can do the calculation, and the server can do the same and do the comparison. So it well not so super easy to use, it's good and easy enough for us to use it I believe, but maybe not for every average computer user, say my mom so to speak, because you usually need some way of additional software, as I said like Google Authenticator or some other thing. And you don't have any form of phishing protection.

Then there was and there is FIDO Universal 2nd Factor, better known as FIDO U2F. This comes as a second factor authentication in addition to your password. So services and web applications can decide to require this mechanism in addition to your usual username and password. It's a kind of more modern one-time passwords, because it's more easier to use, it has support being built in by most modern web browsers. It has a more modern cryptographic architecture, where you don't have a shared secret among client and server, but more a public key cryptography, which you usually would do as of today. And nice benefit is a fishing protection. I will explain shortly how this works. And another thing which many people are not aware of is some form of privacy protection. So what has been designed in the specification is that a specific website is not able to track you as a user among multiple websites, because there's not a single identity, but for each website as an individual cryptographic key or cryptographic identity on the client side, and therefore it can't be tracked among multiple websites. Usually it's not demanded by the specification, but most implementations I'm aware of do it this way is that there is not a fixed amount of storages available in on the client side, but there's a mechanism to derive those keys dynamically. When I talk about this key I mean the client specific key is derived dynamically on the context, therefore you can use it with an unlimited amount of websites or accounts. As I said it is supported by most browsers but so far it has been a kind of proprietary extension to browsers, which is or which has been changed with a WebAuthn but looking backward it has been kind of proprietary, therefore not so many websites supported it this way. The usability was good still though because it was supported by browsers, and browser was aware of this mechanism and then had specific windows and queries to the user like” “Connect now your FIDO U2F device?” and “Press a button”, and things like that so you didn't have to use any additional software.

How it works? I'm not going too much into detail here, though even you I think you can't read it very well, but just on a high level you have this high level flow you will see over all the other FIDO mechanism I'm going to talk about. So on the right side you see the server. Do I have a pointer here? Here's a server which sends, and we have a web browser, and we have a FIDO device like a FIDO dongle, perhaps a USB dongle, a Bluetooth dongle. So the server sends, sorry, here we are in the registration process. So this is the initial registration of a user who wants to add his FIDO U2F device to his account. It's not the login procedure yet. So what the server does it sends client a challenge and its own ID, it's called a “origin” which you can think of kind of a the domain name, it sends this to the browser. The browser verifies this origin or app ID, which is effectively the phishing protection. So if the app ID does not match to the domain of the particular website, the browser would reject the request, so it verifies that the domain matches the app ID. Then this request is sent over to the USB dongle, the FIDO dongle, the user confirmation means the user usually has to press or touch the device which indicates he wants to confirm this request, he wants to do the registration. What the device does is it generates or device, a website, and account specific cryptographic key pair, its elliptic curve key pair, and do a cryptographic signature over a couple of parameters, and sends it back. It sends back a public key, a key handle the signature, also attestation key so that the server can do a verification that the response matches the request, and register now this key handle to the user's account. And then in login during the login or authentication flow it's pretty similar — the server sends or set a challenge and the app ID and also the key handle he has been registered with the user account previously and during the registration. And then the flow is pretty much the same user confirmation, retrieval or derivation of the key and a signature, and this is sent back so that the server can do the verification again. It sees the response matches the requests, it matches also a counter and the user has logged in.

So relatively simple and now this FIDO2 — that's a pretty new standard, it has been I think version 1.0 has been released this year. What you can think of is this FIDO U2F, so this is two factor authentication again. This is used to be in addition to
username a password. And this FIDO2 now is the same as FIDO U2F, but also a couple of more things. Most namely the passwordless authentication. And this can become very interesting, because there with this passwordless authentication you as a web developer, app developer can replace username and password, or first of all you can replace passwords. So that a user does not need to remember any specific password for his account or for your website what he usually would remember or what require to remember as a device specific pin, and this can so device when I talk about device I'm talking about a FIDO device, and this device specific pin can be or is in unique for the device, and has nothing to do with a specific website, so you usually only need to remember one pin and not hundreds of passwords anymore, it can be short thing, doesn't need to be a long passphrase. Usernameless authentication some very similar to the passwordless authentication with a different that so to speak the username is also provided by the server, so that the user does not has to even enter his username, it only needs to deal with the FIDO device to log in and the username is then provided to the server.

It's possible to use it in theory with the different types of devices USB dongle as one type, a TPM or some biometric built in or external device, or other options within this FIDO2 standard. And it primarily written for the web but not necessarily exclusively for the web, so it can be also used for apps or local native applications. The usability is great going to talk about this later. Acceptance as of now is quite poor. I'm aware of Microsoft who has the most acceptance on first of all on Microsoft web services, and second on Windows 10 local machine login. So as well we need because people don't need to remember password to access a local computer anymore, but can login with a FIDO device or FIDO2 device. And beside of Microsoft I'm not aware of any website or service which was supported by now, but I think this was changed in a very soon.

Now what is WebAuthn or web authentication. WebAuthn is a short. It's this diagram should explain it a little bit better. When we have the server and the browser, the web authentication specification defines the API on the browser side, which you as a website developer would use. Behind the WeAuthn there's FIDO U2F AND FIDO2 of which are renamed CTAP1 and CTAP2, and that's a protocol between the browser and say the USB dongle or built-in TPM functionality of the laptop. It's a WebAuthn of the keyboard to come to address all of this. And it's not just specified in 2019 this year, it's also implemented by all large web browsers, even the Far is the latest version implemented it just a few weeks ago or something like that, a few months.

How it works? First of all I have to check the time, I'm again I'm not going to talk about this in very detail, but you see from the bird view it's very similar flow to the FIDO2 flow with of course a few changes. First of all the terminology has been changed, now we are not talking about a server anymore, but we relying party, can be also a local app perhaps, also the USB dongle or other implementation is called “authenticator”, the client is usually the web browser. Then the request has more options. So the relying party or web server can specify certain parameters what he wants from the authentication. This has a beauty that the server can decide on the particular use case what he wants, perhaps for login it one just say a fingerprint on the device, but if you go to some on the website to some certain high security areas, or so perhaps you want to have a second login perhaps, you want to have some biometric verification or something like this, so the web server has a possibility to request whatever he wants even after the initial login through this parameter station. So if for the registration again this is a registration means when a user wants to pair a FIDO2 device with his user account. Yeah, again a couple of parameters we have kind of phishing protection by the browser who verifies the relying party against origin. We have now here hashes calculator which is more detail, and then we have a user confirmation or verification. This sounds pretty much the same but in practice can be different things — a confirmation usually means there has to be a confirmation like pressing a button that the user really wants to approve and wants to execute this operation. Usually this login operation or in this case a registration operation. But the user verification is on the WebAuthn and describe something different, it's more like verifying that the user is really the use I he claims to be, and depending on the FIDO2 device different mechanisms to ensure the verification — it can be entering the device pin I mentioned earlier, it can be using some biometrics like a fingerprint to verify that the users really the user, say the owner of the FIDO2 device. Then again cryptographic key pair is generated, a signature as calculated, and the response is being sent back to the relying party who does a verification. And then the actual login procedure or authentication looks again similar. Here first and second factor refers to a second factor refers to FIDO U2F mechanism, and first factor first to passwordless authentication. So actually it's not just a first factor like a password is more a first and second factor. But the flow is very much similar, the difference are only the parameter. This is why it's here combined on a single slide. The relying party sends a challenge, a name of the relying party itself, the browser again there's a phishing protection by verifying the relying party again origin, perhaps some credentials or the parameter of whether user verification is required or not as is transferred, and again the authenticator does whatever's required to login say requiring just press of the button or some pin and then the response is sent back to the relying party who does a verification against key pair which has been registered with a user account in the previous step, in the registration step.

So for usernameless authentication the main difference is that here on the client side, think of it as a web browser, the web browser would show to the user a kind of user interface, kind of window where the user can select the identity he wants to use to login to this particular website. So yes there is a user name involved but it's not involved on the website anymore, it's only client side, so it's a native window of the browser. I think this feature by now is only supported by Google Chrome, I'm not sure about this so this kind of more advanced features of WebAuthn earlier I said all major browsers do support WebAuthn and which is true, but I think those more advanced features are not supported by all. I hope this is going to change. Then the user selects which ID he wants to use to log into this particular website, and then the similar flow is executed as previously. Here in the response web service or the relying party also gets the username of course, the username the user has chosen here.

Now what to use? This kind of summary slide pretty much my last or second last slide, so that we may have a minute for questions perhaps. I think password authentication is for simple projects, for project without any security focus. I think there will be a shift among the ecosystem that more and more websites and apps are moving to one way or the other of these WebAuthn and authentication mechanism, so that the acceptance or what user actually demand from websites is going to shift towards a WebAuthn based authentication for security critical or on users view for the important websites. So OTP I won't recommend to implement anymore, if it's there it may be good, it may be sufficient but I won't recommend you guys to implement it in any new projects anymore, but instead of OTP use either WebAuthn and the second factor so FIDO U2F, or use what I described this is passwordless authentication or even usernameless authentication. However this requires more implementation effort. They're not there are some a couple of minor of libraries available say it GitHub or somewhere else, and the Internet you can use depending a programming language, but there are not so many. So it's still some pioneering if you're going to implement it. And also if you are looking at this passwordless authentication, make sure that the web browser does your user or customers use really support this.

So here we have a couple of references. The first one is can be very helpful for OTP, but also rap out and it provides an overview of popular and non popular above a couple of hundred websites and provides an overview which type of mechanism they are going to support, with mechanism I mean either OTP or WebAuthn slash FIDO mechanism. This can be a good starting point if you want to decide as a user which secure authentication mechanism you may want to use. Then the other is more for developers who want to look into the specification itself, or maybe prior to looking into the specification we'd on this guy here he has a couple of good introductions, not only the single one here but also come some other follow-up blog post about WebAuthn.

Yeah that's it from my side. Do we have time for questions? I think this means we do have time for questions. Ok, any questions?

_Audience:_ Hi, thank you for your speak. How to validate the direction against the domain name, how is this validation realized?

_Jan:_ This is implemented by the browser. So you as a developer so to speak don't need to care about it. Yes you do need to understand how the validation is done, say if the sub domain is considered or not those kind of things you do need to know but you don't need to implement anything around this. This is comes out of the box. One thing which is required as HTTP so it FIDO and WebAuthn won't work with plain HTTP, and for the sub domain things I think there's some better explanation visually where you can which if I can find there are some tables with examples, this is more easy to understand than me here in the in the open space. Follow the references and you will find it.

_Audience:_ So thank you for the nice talk. Do you know an overview about tokens which support FIDO2? I searched a bit and it was a big chaos of sources and information, and it seems that some is not up to date as some sources are not up to date and it's hard to find which features are supports by which FIDO2 keys.

_Jan:_ So the information of which device supports FIDO2 in general is available here, first of all our own Nitrokey FIDO2 device is available, then also to name Solokey which is kind of related, other open source project, YubiKey as a big competitor as well, and I also a couple of others. I think the next question was here? Are you?

_Audience:_ I'm next. I recently implemented that as an proof of concept for my company, and I was very surprised that Safari on MacOS was able to pass a pin required for passwordless login, is a pin implemented by a hardware or by the browser?

_Jan:_ Met by the browser. So the browser should prompt the user to enter the pin yeah.

_Audience:_ So I edit the YubiKey via Chrome, with a pin required? And then I used Safari, and Safari could just access the key without a pin and just use the first one if it multiple, but could not select which one and I was very surprised by that.

_Jan:_ Sounds like a back or weird implementation in Safari, but in the end this relying party, the server should verify that the response also meets the criteria he's requesting. So there it should fail eventually and not bypass any legitimate authentication.

_Audience:_ In the response from the browser to the server includes if a pin was entered?

_Jan:_ So, say this year yeah I'm pretty sure yes, this information is provided in the response so that the server can verify this. The server must not trust any middleman browser, anything like that, no.

_Audience:_ Yeah I think then Safari is backed.

_Audience:_ Talking about business solutions. Is this fully supported in the business environment where the user is an thin client or something a small device, then remotes into a service for example, that's the FIDO2 or similar solutions passed through and is there are some limitations?

_Jan:_ So business environment you're talking about the Windows for example? So I know that for Windows earlier I mentioned the login tools and the local Windows machine, and this for example requires an Azure Active Directory. It doesn't work yet with the local active directory, so that's a big limitation. I expect Microsoft to add sooner or later to add this feature also to local Active Directory for other like environments, business environments, I'm not aware of any out-of-the-box implementation or support of this.

_Audience:_ My question was less than the authentication against the Windows or the remote server, but then passing it through into the remote session. So I plug in my FIDO2 dongle and at my station, and on the server I can use it in the browser window for example?

_Jan:_ So you would need a way to pass through the USB device to the client session.

_Audience:_ So it's just a normal USB device not like a special funky like smart card or something?

_Jan:_ That's right it's a norm, very ordinary used USB device, it goes as USB HID class, human interface device, there're also mouse or mice and keyboards are assigned to this USB class, so that's a very default you speak class.

_Audience:_ Ok, thank you so.

_Jan:_ If you talk about a VM or syncline some of you may need to pass through the USB device, but don't need any specific driver for FIDO. Last question? Yeah, ok. I think time’s over, maybe you can find me around here. Ok, thank you.
