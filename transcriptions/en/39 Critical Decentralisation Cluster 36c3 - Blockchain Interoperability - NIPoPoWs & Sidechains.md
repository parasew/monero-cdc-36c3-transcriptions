# Kostis, Dionysis

_**Critical Decentralisation Cluster 36c3 - Blockchain Interoperability NIPoPoWs & Sidechains**_

[youtu.be/ufnw0fW9UuU](https://youtu.be/ufnw0fW9UuU)

_**Abstract**_

We will talk about various means of communication between proof-of-work blockchains such as superblock NIPoPoWs and how to use them to build one-way and two-way transfer of information between chains without a trusted third party.

_**Transcription**_

_Deana:_ Hey everybody, are we ready for the next talk which now I know the schedule of? I got the correct schedule, and I'm genuinely also excited about this one, because interoperability is a very, very important subject, and it's very, very current in terms of how we're going to actually bring these technologies together, and how we're gonna transfer value in between chains. So Kostis is here to do this talk, and everybody give him a hand and welcome him on stage.

_Kostis:_ Hi everyone, this is fine, ok, cool. My name is Kostis, I work at IHK. I will be giving this talk with my colleague Dionysis Zindros who is a Bc. student at the University of Athens. So I guess let's start, I also have a clicker, yeah, that's better.

So in this talk we'll kind of have a discussion about what a sidechain is. There were some talks before that we were talking about sidechains, but I will probably define what the sidechain is. And then we will basically see, how I can build on top of sidechain, and to build a two-way peg, which is basically an asset that is shared through different crypto, different chains basically. And then in order to do that efficiently we will see Proof-of-Work, which will Dionysis will present. So let's quickly talk about sidechains.

So this is actually a very nice diagram here, which shows two chains, which are completely, not really any to each other, like they have different genesis, and we can see that this white block basically depends somehow on this black block, which is on another chain. And this is kind of the theme here, we want chains that are completely heterogeneous and different to be able to kind of see information about each other.

So what happens here. I'm going to use as an example Ethereum and Ethereum Classic, it's easier this way. And so what we have here is these chains? Like they grow over time until at some point some event happens, which we denote with this frog, and this event happens on Ethereum in this case, and then what we want to do is we basically say: "Ok, we would like to know about this event on Ethereum Classic chain". And here we denote the fact that we know about it with another frog, and we basically can react to this event in any way, we could react to this event on Ethereum. So this is like the big idea about interoperability right — we want to be able to react to an event on another chain.

So we have some terminology here, which will be useful to go through. Then we have in this case the Ethereum is the source chain, like the chain in which the event originates, and Ethereum Classic is a destination chain, we also call it the target chain. And so basically here we have some requirements for this. We would like for the blockchains to be Proof-of-Work but it's not a strict requirement, but it's this is a case we're going to look at today, and we have some examples of some cryptocurrencies that are Proof-of-Work. And then in order to do some of the more advanced stuff that we want to do, we also have the requirement that the cryptocurrencies also support smart contracts. And we are going to do some advanced stuff that we really take advantage of the smart contract capabilities. And this is kind of a departure from all the previous talks, which were kind of about Monero. Monero doesn't really have smart contract capabilities. So this is I guess a nice change of pace.

So when I showed the frog there, it's like it wasn't really obvious what it represented, and so we'll make it more specific. An event can be something like, ok, this transaction, like this transaction happened on some chain, or this block was mined, which I don't know has this particular property, it's hash has like I don't know seven at the end or something, or changes in the account balances, and other kind of events like solidity events. So for those of you who don't know, Solidity has events that can be fired, and they're recorded permanently, and they can be used by other applications. And we are actually going to make heavy use of those solidity events.

And now there's another thing which is important, which is ok, someone could say: "I can do this by having a miner on the destination chain, observe the source chain, and he can confirm or they can confirm what happened on the source chain". But we don't have, we don't want to place this burden on the miner, and we actually what we try to do in this work is we try to say, how can we do this without actually affecting the base layer and without requiring changes, constantly changes. So we have a property which we call "miner isolation", which is very important, and what I'm going to present is actually does have this miner isolation property.

So we are going to start with a smart contact, which is called "crosschain". This slide here shows that this is actually on the destination chain, and we're basically going to like our work in this will be to tell the smart contract that some event happened on the source chain. And these all starts with like this all the smart contact knows is a genesis of the source blockchain. This is all the information it needs in order to operate, and this is what we denote here. So we kind of construct the smart contract with genesis of the source blockchain.

Now we saw what an event is. Now we will see how it improve such an event happened, and we have two important pieces: one is the event itself, like we want to have some description of the event, and another is a proof that event happened. And when event happens it gets stored, so that we can use it for other things later, and we'll see how we can use it, we will actually make use of it.

So what does a Proof-of-Work, we for now we'll look at very simple proofs which are SPV, like if anyone's familiar with a term which is basically something some event that happened basically took place in a block, so I want to prove to you that this block is actually in the best source blockchain, and this event or this transaction is included in that block. So the way I do it is I provide to you the chain of headers, and I provide you a Merkle proof of inclusion for the block in that I'm interested in. And that this is not what we're actually going to end up with that, this is not like incredibly efficient, and there are ways to improve it that we propose, which Dionysis will present it a bit.

But this is not enough basically because the information this contract has is very limited, and someone could lie about it, someone could provide invalid chain that contains some transaction that is actually not in the best source blockchain, and how we avoid that as we say: "Ok, you claim now that this happened, but we will offer, we will start a contestation period". So that if someone disagrees with you, we will provide them with the opportunity to say: "Ok, I disagree, and this is why I disagree". So they will provide a contesting proof that basically your proof will be compared against, and if it is found out that they thought the person who contest is right, they basically gain some collateral. Otherwise like nothing happens and when the conversation period ends, I'll actually circle back to the collateral thing, because it's more important. The important part is here that you have four proofs in case the first person was lying.

So this is again now a recap of the of the SPV protocol. So we have two provers, these are actually parties that submit things to the smart contact, and they submit their chain the header chain, and both submit the chains, and they are basically compared in this very simple scenario, the comparison happens with checking which chain is longest, but it can also be which chain has a most Proof-of-Work, which is in Bitcoin and so on.

So let's look at the contract. This is a function that is, this works, ok, this is good, so this is a function that gets called on the smart contract, when someone wants to say: "Ok, this event happened on another chain", and it has a proof which is this π, and it has the event that they basically came happen, so the event could be you know this transaction happened to this address. And then the important thing is before we go there, the important thing is when they, when someone does this claim, they also have to put down some collateral which can be taken from them in case they're lying, which is the thing I want to set back to you. So this statement here is it verifies that they have actually put collateral, and then we basically store this event that they say: "Ok, this is the offeror which is a person who called the whole this function". And this is a proof that they use, and then we say: "Ok, now the contestation period begins, and it will end after K blocks". So this is a whole function is called "submit event proof".

Now again when someone wants to contest it, they have K blocks in which they are able to do it. And again, if they are right, they pay the collateral, sorry, they get to collateral as reward otherwise. If no one manages to disprove this event, then the original claimer gets this collateral, they get it back, because they are the ones who could it. So there are some conditions this collateral should satisfy, which is basically at the very least it should cover the cost of submitting and the cost of monitoring the source chain, yeah, submitting and monitoring not only the source chain but also a destination chain.

So let's see this function as well, and let's get over it quickly. So basically we have a check that says if the chains ok. This event exists and we are still within its conversation period, and now that comparison happens, and basically the two proofs are compared. So this is the existing proof and this is the new proof, and then this is this is a scenario in which the original proof was actually fraudulent, and so it gets cleared up, and the person who submitted this contesting proof gets collateral.

So when this happens we basically assume that someone claims an event and correctly so because the event actually happened, but time passes and then the contestation period ends. So we have a way for the original claimer or basically anyone else to say: "Ok, now the contestation period is over, nothing happened and let's finalize". No, actually the offeror does it, I'm sorry. Correct that. The original offeror has to do it because they have to get back their collateral. So when the contestation period is over, which is verified by this, the original claimer calls this finalized event function, and then basically their event gets added to a set or finalized events, and the offeror gets collateral back. And this is a happy case. And then this smart contract, which is basically we've been talking about one specific smart contract during this talk, this crosschain smart contract we will use as a base for other smart contracts, and it offers this nice API, which says: "Ok we have this event exists", and you pass it your event that you're interested in, and you can tell you did this event happen, and it in this way you can know.

So now that we have that in place, let's look at how we can make a two-way peg and let's first look at what that two-way peg is. So imagine you have some Ethereum on Ethereum chain, and for some reason you really want to use them on Ethereum Classic, because I don't know, because you feel the transactions there are cheaper or you have some reason, or you want to use a method X which is Ethereum Classic. It doesn't really matter. The point is that you have some reason that you want to use this Ethereum on Ethereum Classic. So what you want to be able to do is say: "Ok I now transfer this asset to a Ethereum Classic", and then use it as a regular token, send it to people, send it to smart contracts, do whatever with it. And then you basically want to say: "Ok, when I'm done with it on a Ethereum Classic, I want to return this on Ethereum and keep using it there if I want to". So this is what a two-way peg is, and now let's look at how we make it basically.

So we have two smart contracts to do it, which both inherit from this cross-chain smart contract I showed already as a base. And the first one contract is this X, which is on Ethereum, and the second smart contract which we call Y, which is on the Ethereum Classic. So the Y smart contract, it basically represents ERC-20 token that mirrors Ethereum on Ethereum Classic. So what we want to make is you basically have a token that when you have it, it's like you have one Ethereum. And the way you get this token is, the only way to get it except if someone sends it to you, is by basically freezing your Ethereum in the smart contract X. When you do that like your Ethereum in the smart contract, ETH is locked, and then if you have some Ethereum tokens, some ETH-20 tokens as we call them, on Ethereum Classic, you can basically take them back, you can recover them on Ethereum by destroying them there.

So this is like the same slide as before, but with the details we have now. So basically if I have a Ethereum, I move them in this contract, and then I somehow transfer this, and we'll see how it's done, to a Ethereum Classic, which basically meant those tokens, those ETH-20 tokens. And then anything can happen here, like we can send them to someone else, that doesn't matter. But then at this point someone who has them says: "Ok, now I want to destroy them and get Ethereum".

And so let's for a moment assume, that this can be done easily, and this can be done easily, and when you burn X Bitcoin or any amount, when you burn five Bitcoin, five Ethereum, sorry, well five Ethereum, you get five ETH-20 tokens, and then when you burn, when you destroy five ETH-20 tokens here, you get 5 ETH.

If we assume this is true which it will be, and we'll show how it's done, then there's an argument to be made that the price of this token is actually the same, as if basically. So they have a one-to-one correspondence. And the reason is that if the prices were any different, there exists some arbitrage opportunities. So if Ethereum price is higher than you basically buy the token, then converted to Ethereum and then sell that and vice-versa. So this is kind of an argument to us why these tokens basically will end up having the same price. And with this we now see that, ok now we took ETH, we brought them to Ethereum Classic and back basically. And now let's delve more into that the details of how this is transfer, basically how this part is done.

So I will start now referring to these chains by their Genesis, and for a moment say with me and assume that Ethereum  and Ethereum Classic have different Genesis. And so the two chains again this says that they need to be Turing-complete, and the important new thing here is that these chains we have the assumption that independently they are secure. So that this is an important assumption, the only one we have to make. And what we will do is when we kind of show already is that we make a token which mirrors the token on Ethereum, but we here we call it G1, the Ethereum called G1.

So this is the basically the code for this smart contract. Again this is on Ethereum, this is sidechain 1, and it inherits from cross-chain. And again the information it needs to know, I need to know what the Genesis of Ethereum Classic is, and like it does have it here of the other chain, so G2. And then it also needs to know the address of the same smart contract on the Ethereum Classic. Now again this shows that the Genesis is recorded. And this is an initialization that can only happen once, and before it's on the contract is different after it's done it can be done again.

So we want to basically record a specific event that happens here. And this event is that, when we want to obtain funds on the destination chain or Ethereum Classic what happens is what we want to ensure is someone paid money into contract X, and they locked it, and this transaction actually happened, it's in a block, then this block is stable and it happened on the Ethereum chain. So we have a Solidity event that's fired when this happens on X, and then this whole event is basically the proof that it happened for the smart contract on Ethereum Classic.

So what we do is we have two smart contracts, if we pay Ethereum on this one, we are able to send it over to Ethereum Classic. And if someone from Ethereum Classic has basically destroyed the tokens, they can prove it here and get it in Ethereum. And the same thing happens here.

So let's see what this suppose it does. This first deposit happens on Ethereum. So this is basically a payable function, so we don't need to mention the amount or anything here, and so we say: "Ok, we took this money, which is this message value, and we want it to go to this address", and then this is just account, And then this emits an event, and similar thing happens here, here is on Ethereum Classic chain we have some token and we want to get it on Ethereum. What we do, we depose it, which is basically ERC20 token here. And we basically take this amount that we say we want to destroy and obtain on Ethereum. It gets removed from our balance and then this event is emitted. And again this is the event, is the other event. This is again the initialization, we went through it.

And now we want to look at what like the other side. So we saw how we take money by depositing, now we want to look at withdrawing. So now this withdrawal function happens when someone destroys their tokens, their ETH20 tokens on Ethereum Classic. It makes sure that this event was fired, the event that we saw before, make sure that this event was fired, and if it was then it sends basically the amount. And I think this is actually a mistake here, this should be target. And on the second track or on the Ethereum Classic the someone calls this, when someone on Ethereum has paid money in to contract X, and this ensures that the appropriate event was fired, and then it credits them that amount, as in ETH20 token.

And now this is like the whole contract which I think we don't need. And now Dionysis will come up and keep going with NIPoPoWs which is a way to basically improve this.

_Dionysis:_ Ok. Hi everyone. I'm Dionysis. Is it too loud? Ok. In the light, yeah. Thank you, sure. Ok. So the way Kostis presented these smart contracts, he talked to you about this central piece of these smart contracts which is called "event exists", which verify something happens on the remote chain, and we kind of kept it hidden. Kostis told you, you know, the way that this works is we have this parent smart contract that everybody inherits from, and within that smart contract there is this, it basically maintains the chain of all the blocks, all the block headers of the remote chain. So the way that it was presented, event exists essentially requires that every remote block header is sent to the blockchain for verification. So in our example when we're working here in Ethereum, Ethereum needs to know every header of Ethereum Classic. Obviously this is not very efficient, in fact if you try to do that in practice, this will exhaust gas limits quite before you reach the point where you can run these verifications.

So obviously this is not very efficient or doesn't really work at all. So we want to see how are we able to do that without sending the whole chain. Before I get into the details of NIPoPoWs which is the way to do that, I just want to ask the audience if there's any questions on the construction we showed so far, because we will get a little bit more technical now. So any questions about the smart contracts that were presented previously? Ok, so let's move on to NIPoPoWs.

So the question with NIPoPoWs is essentially you have this kind of situation where you have this event fired, in our case smart contract, and you have several provers, some of which are honest and some of which are adversarial. And all of them are submitting some information to the smart contract. The way we showed it before, we said they will submit the chain of all headers of the remote chain. However we want to somehow optimize this. And the question we're trying to ask is can we do that without submitting every header or do we have to submit every header, or can we do it in a compressed manner, can we send less data here between those two approvers to the smart contract, so that this is more efficient and we can do it within the gas limits of the existing blockchains. And one thing I want to repeat that Kostis already said is that the point in these smart contracts is that we want them to work over existing blockchains. We don't want to build a new blockchain system where there's weird stuff happening right. So we want to do it on top of existing systems. So the protocol we're looking for is both of these we'll send some sort proof, short proof, π1 and π2, and these are not really the chains themselves, but there's some sort of compressed form of the chain that attests to the fact that there has been some work that happened on that chain, but without actually revealing all of it. And somehow the verifier needs to know whether that the event that it's trying to verify happen or not. So over here the verifier is asking about an event, this event is what Kostis talked about, whether a transaction happened, whether a particular payment happened, or whether an event happened within a smart contract, and that event pertains to the actual chain that is the longest chain on the underlying protocol. However here we don't want to send the whole headers. So the question is what are these sort of things that these provers need to provide to the smart contract, so that the smart contract can perform some sort of comparison between them and know that this has been happen or this event didn't happen.

So what we're looking in reality here is that the adversarial prover what they are trying to do is they could be a mining adversary, so they could be trying to extend the source blockchain, they could be trying to mine blocks, create forks and so on. However they need, we need to be able as verifiers to reject their claims if they belong to not the longest chain of our system, if it belong to a shorter chain than the current longer chain their events need to be rejected. So that's the question how do we do that.

So the basic idea is based on extending the Proof-of-Work equation that Bitcoin and Monero and Ethereum all use. It's all the same. So let me just remind you what this equation looks like. So recall that we're using a hash function, it could be like SHA-256 in Bitcoin. We pass it the block header, and then we check if it's below a certain target T, so if it's small then this equation is successful, and this is a valid block with a valid Proof-of-Work. And we consider this hash function to work as a random oracle. So if you pass it what does that mean, it means if you pass it some new data that you haven't asked it before, you can assume that the output of this hash function is randomly distributed completely uniformly over its space.

Ok, so this is the interesting observation that we're making and this is the basis of the construction that allows us to compress blockchains. And the idea here is that we want to have these sort of superblocks, basically we're not creating a new block type we are looking at the existing blocks of the blockchain, and we're looking at certain blocks we're naming the superblocks if they have a certain attribute. And this pertains to blocks off the source blockchain, and we call something a "superblock" if it satisfies this equation. So let me just go over that. So all of the blocks satisfy this part of the equation here up to T, so the hash of the block is less than or equal to T, but some of the blocks that we are dealing with will satisfy this equation really, really nicely, much more than is required by the consensus protocol. In particular if you thinking of blocks as having a hash that starts with a particular number of zeros to make them valid blocks, what we're talking about here in terms of superblocks, is blocks that have many more zeros at the beginning of their hash than are needed. And in particular μ number of zeros that are extraneous and are not needed. So this is the so-called "μ-supertarget", and if a block satisfies this equation with an additional number of μ zeros we call it a new "μ-superblock". So if it has an extra zero it's a 1-superblock if it has ten extra zeros it's a 10-superblock. And these superblocks get really, really rare as you increase μ. So if you make μ let's say 10, then only one in a thousand blocks is a 10-superblock. And to be precise this is the probability that a block will be a superblock of level μ given the fact that it is valid block. So if it is a valid block then the probability that it reaches that new superblock property is given by this 2-μ. So all blocks are 0-superblocks, half of them are 1-superblocks, then a quarter of them become 2-superblocks and one eighths become a 3-superblocks. And so on essentially these the number of blocks that are at the next level are half in expectation than the ones in the previous one. So that's what we mean by a superblock.

And so our chain, so we this is what we call the level of a superblock, you can actually write it out mathematically, but it's exactly what I described. So this is actually how the blockchain looks like if you render it under these lens of superblocks. So the chain is really just a zero level, there's nothing changed we don't modify the consensus protocol, but we just interpret it in a certain manner. And what we're looking at is we're observing that some of the blocks are 1-superblocks, like there, and some of the blocks are 2-superblocks, and some of the blocks are 3-superblocks. So you can see half are 1-superblocks, then half of those are 2, and then half of these are 3-superblocks. So they become really rarer as you go up. And this is just an interpretation of the underlying chain, this is not new blocks mined on top. The chain remains the same.

So using this idea we can compress the Proof-of-Work that happened on the chain. And the way we do that is, by the way this is a probabilistic data structure, because blocks hashes are random, so it might not be distributed as nicely as is shown here. This is just probabilistically the expectation, and actually it looks like that, but you might have some distribution that has some differences here, so it might not look as symmetric as this picture.

Ok, so the idea in creating these NIPoPoWs or the proofs from the provers to the verifiers that are compressed, is that we will just send superblocks instead of sending the whole chain headers. So we will send some representative blocks or block headers that somehow capture the fact that Proof-of-Work happened without sending the whole Proof-of-Work. And this is why we call these "proofs of Proof-of-Work", because they prove that Proof-of-Work happen without actually showing all the Proof-of-Work. And the this is called PoPoW Proof-of-Work and the NI on the NIPoPoW means "non-interactive", because we just generated one, send it to the smart contract and then the smart contract can verify it on its own.

So here's the basic gist of the idea, and so the way we do it is we choose a specific level μ suppose we choose a level μ equal to ten and then what we say is: "Ok, I will not send you the whole chain and the whole chain headers, I will just look at all the blocks that are 10-superblocks and those 10-superblocks that are only one thousandth of the size of the blockchain only for this I will send you the headers". And then what I ask the smart contract to do is compare who is sending the most superblocks instead of who is sending the most blocks. And based on that again, based on how many are more which proof has the most length, that's the one that wins.

So the protocol now looks like this — you send two short proofs which are essentially just superblock headers, and they are compared like that so you count the number of superblocks of that particular level μ, and you see which one has the most. And that μ for now you can assume it's just a fixed constant, you can think of it as μ equal to ten, the smart contract fixes that, it checks that everything inside here has Proof-of-Work which is with ten extra zeros, and then looks at these chains to see, how they compare, even though they have skipped many blocks — they have skipped a thousand blocks for every superblock that is presented there. And again the Merkle tree proof of inclusion within one of these blocks is fully included. And for the purposes of this talk you can just assume that the transaction is a part of one of these superblocks, even though if it is not we have mechanisms to actually show that it is part of the chain that is underlying there.

Yeah, ok, so one of the problems in this construct, as I showed it like before, is that if you just send superblocks there is no ordering in them, because there is no provided link pointer as we're used to in Bitcoin or Monero, where we have every point, every block pointing to its parent. So we need a mechanism to have these sort of blocks sorted in a way that is chronological, in the way that they were generating the same order they were generated. Because if we don't do that then it's possible that the adversary will just reorder the blocks and cause us to think that the blockchain has a different order than it actually does.

So we need to extend our structure to look a little bit like that. So we want the blockchain instead of having a provide a pointer between every two blocks, we want every block to also point to its most recent block at the same level. So you can see here every zero level block of course points to the most recent zero block, but every 1-superblock points to the most recent 1-superblock, and every 2-superblock points to the most recent 2-superblock and so on. And by the way if something is a 2-superblock, if something is a 3-superblock, it's also a 2-superblock, because if something starts with three zeros, it also starts with two zeros.

So we want this kind of extra pointers to exist within between blocks, this is not something that exists in the current implementations of blockchains, however there is first of all in Ethereum, there is a plan to add this kind of structure in EIP-210, which is going to be adopted soon. And even if it's not adopted as part of a consensus layer, we can actually extend the existing data structure of existing blockchains to include these pointers without a softfork and without a hardfolk, and we have some literature references at the end that you can look at for that. So actually this is not a problem in what we're trying to do here.

Ok, so let me just say a few words about how this actually works, because I skipped some of the technical details to make it a little bit more precise, because it's not sufficient to just send superblocks. And the reason being… oops, there we go, ok, so the problem is, let's see, the problem is if you're trying to just connect, if you're just trying to compare two chains that what happens, one is about Ethereum, and one is one is about the longest chain in Ethereum, the other one is about a fork of the Ethereum, and you just send superblocks, it's possible that these two proofs diverge really close to the end of, so that really close to most recent most recent blocks, and the problem with that is that you cannot really do a fair comparison at that, it has security problems. So the way that we actually build these proofs is that what we want to do is the verifier needs to be able to compare these proofs at any level μ that it chooses. So here's the construction let me show you, the construction and then I will talk about precisely how the comparison happens.

So first of all this is how the honest prover will construct a proof that it was sent to the smart contract. So it takes the actual chain which is the whole chain of old block headers of the chain is trying to prove things about, so the source chain it takes a certain number of blocks from the end, k number of blocks which could be 6, and those blocks it sends all of them in that proof. So the last 6 blocks of the chain are always sent. So that's called the suffix of the proof. Now for the prefix part which is the stable part of the blockchain, this is the long part of the blockchain that we wish to compress. So the way we do that is we have some sort of a security parameter m and that security parameter could be something like m is equal to 3. I will show the example with m is equal to 3, if you want to make it secure this as a parameter you want to grow to a larger number, let's say around 100. The way we do that is we start with a chain, we start with a level of superblocks that has at least m blocks. So in this case we're looking at m is equal to 3, we want to include the top level of superblocks that has at least three blocks, so in this example there's only one 3-superblock, and so that one we will do, we don't want to include that but the top level that has at least m is equal to three blocks, which in this case is level two, we want to include it fully. And then what we are doing, what we're going to do is we're going to look at, so we're going to look at the top level that has at least m is equal to three superblocks, and then we will look at the suffix within that level that has a length of three, and we will try to fill in all the blocks on the level below, that connect these two ends of this level, here level two. So those are the blocks that we include from level one, and again we do the same thing at level one — so we look at the last three blocks of level one, and we fill in all the span here with zero level superblocks. Ok, so we do this, obviously this is a toy example, in real Bitcoin this is gonna be like thirty, thirty seven levels. So we start at the top level, and we start filling them in. But because we fill in, we just take m blocks from the end, this level here, will just have three blocks included. This one will cover those blocks, and this one will cover those blocks. So what I want to argue here is two things: I want to give just a bit of intuition about how the comparison is gonna go, and that's the first thing. And the second thing I want to show you is that I want to argue why this sort of proof is short. So why there's not too many blocks needed when you send this kind of proof.

So about the second part first, these blocks here that I've highlighted are all part of this proof, so this is exactly what is submitted to the smart contract. We want this to be a short amount of blocks, a small amount of blocks, because we want this to be gas sufficient. Ok, so at the top level we're just including about m blocks, because it's the top level, it's the highest level that has at least m blocks. So this will have about between m and 2m blocks. And let's think about why this is true. Well first of all it has ten blocks, because this is a requirement we were required to have at least 10 blocks. But I'm arguing that it will not have more than 2m blocks, because if it had more than 2m blocks here, because this level has about half the blocks at this level has, then if this had 2m blocks, then the higher level would have m blocks, and that would be the higher level, the highest level that has m blocks. So that would have been included as the top level. Ok, so the top level has between m and 2m blocks, that say has about m blocks. Now every next level that we fill in this manner will have approximately 2m blocks. Why? If this level, if in this level we take the suffix which is of length m, and we fill it in, because the level below will have double the blocks at the top that the level above it has, the level below will have 2m if this has m here. We take another suffix that is of length m, and we fill it in with the blocks of the previous level. So again that makes 2m. and then if we were to go on, we would again take m blocks from the end, fill them in, take m blocks from the end, fill them in, and so on. So for every level we take about 2m blocks. Now I want to emphasize that the number of levels that we see here is going to be small. Why is this? So if the blockchain itself has C blocks, then the one superchain has C halves, the two superchains has C corner blocks and so on, until we reach a chain that has just one block. And then we're done. But how many times you have to divide C by 2 to get to 1? Well that's just the binary logarithm of the chain size. So the number of levels that you see here is just a logarithmic in the number of blocks that have been included in the chain itself. So essentially this grows logarithmically with time. The number of levels grows logarithmically with time. This grows really, really slowly as time evolves.

So the argument here is that the number of blocks at each level is a constant that we choose. It could just be a hundred. The number of different levels is something that grows very slowly. Therefore these proofs are going to be short. And fact we have some measurements that you can look at in our papers, that show that it is actually the case. So this is the argument for something we call "succinctness". Succinctness says that these proofs are exponentially better than actually sending the whole chain of headers. And if you want to look at it at asymptotic notation this is the kind of expression we're looking at, it's the logarithm of the chain times m which is the, so this is the number of levels this is the blocks that we include in every level, and this is the fixed number of blocks that we send at the end. So the proof size is really quite small, it's polylogarithmic in the chain, it's actually logarithmic in the chain. So this is essentially an exponential improvement over sending the whole chain itself.

So for the security argument what we want to do is we want to compare two NIPoPoWs that were sent by two verifiers. One is NIPoPoWs that the adversary sending, the other is NIPoPoWs that the honest party is sending. And we want to see who's talking about the longest chain, on the source block chain, who has the longest chain there. But in order to do that what we're doing is as follows, and this will kind of give you some intuition about why we do this whole business with multiple levels, where we kind of try to fill in the level below with covering the blocks at the level above.

Ok, so the way we do this comparison is that the smart contract received these two proofs π1 and π2. π1 and π2 are just chains of blocks that have some blocks skipped, most of the blocks are skipped, and what it does is it tries to find a common prefix between these two. And this common prefix will be non empty. So this what this notation means, it's just the common blocks between these two chains. These common blocks between these two chains will necessarily have at least one block, because both of them have to start from the same genesis. And between these two common blocks we find the most recent block. So that's what this means. So from this chain of the common blocks between these two proofs we take the latest one. And now we want to do a comparison and say: "Ok, this guy's right, this guy's wrong", one of them is lying about what is the longest chain. So what we do is we take this the most recent common block between these two, and then I am using kind of weird notation here, let me just explain what that means. Is for every level μ we are looking at the blocks of, so ok, so for every one of the set two proofs π1 and π2 we take only the part of that common block. We take the part after that common block, and we only look at one particular level of our choice μ, and the choice we make for that μ is we take the higher one, the highest one that in this kind of portion of the blockchain has at least m blocks. So the length of the proof from the block B and afterwards at this level μ has at least m blocks. If you look at the construction that we have, this will always be possible to do, and we have a very elaborate argument in the actual math that we do, but I hope this gives you the intuition about why this happens. So after we choose a level μ where this happens in both of these chains, what we do is we compare the lengths after this particular block. So the length comparison happens after the common block, which is time that the two different parties would have to have mined independently of each other, the one of them can all use Proof-of-Work that the other one has stored. So I know this is the long formula to take in within a short talk, but I hope this kind of motivates you to look at the work we're doing and the papers where the more of the details are in there.

Ok, I will skip these, but give you some of the references that we have so that you can take a look at these. So first of all the "Non-Interactive Proofs of Proofs-of-Work" construction is a paper we're publishing in Financial Crypto in February. So this has all of the math things where it talks about, how you construct the proofs, how do you do this comparison, and why this is secure. Then we have this "Proof-of-Work Sidechains" which is essentially the first part of the talk that Kostis showed you, that explains why the smart contract works, and this was from Financial Crypto last year. This is I think it's an easy paper you can take a look at the smart contracts and even implement it. Then we have "Proof-of-Burn" paper that shows how can you destroy money on one chain and using the previous mechanisms you can prove that money was destroyed and transfer it to a different chain. And then some of the other interesting things here are this "Compact Storage of Superblocks for NIPoPoW Applications", as well as "Enabling NIPoPoW Applications on Bitcoin Cash". These are basically an implementation in practice of these ideas, we were able to do this an actual Bitcoin Cash. We used Bitcoin Cash because it just has cheaper fees, but it doesn't make any difference. You can do the same thing on Bitcoin itself. So we did it on Bitcoin Cash testnet. Actually this is Kostis master thesis, and that was deployed and it was done without actually doing any software or hardforks, so that's an interesting piece of work. And then there's another master thesis from last year that shows how to do this in an Ethereum smart contract, and this one also has a few measurements that show that this has sufficient gas efficiency compared to sending the whole chain.

So yeah I know this is a lot of math to take in, this why we have all these references and I hope you can take a look at these to dive in a little bit more depth in what we're doing here. We also have a website called nipopows.com that you can look at. It has all these references and a few more videos that show you some of the details of how we do these things. Yeah that's all I have, so thank you very much, and we'll be taking some questions, we have some time for questions now.

_Audience:_ Do you have any formula for computing the amount of the collateral of the deposit? Because I fear that even if the deposit is quite large, if the mining works for a long amount of time, no one has an incentive to actually perform the checking, because there's never any and again made for it, and yeah that seems to be problem for me.

_Dionysis:_ Yeah that's a good question. So we have this kind of, you have it somewhere here right about the collateral, let's see. Yeah so we have it here like we have some intuition here, that it has to be sufficient to cover for fraud proofs. I get your argument that even if this is sufficient basically due to economic reasons nobody's going to do it, because they will always get caught yeah. So there is a more advanced argument on that on the true bit paper which is not ours, that gives some mechanisms in which basically one way you can do that, is you can sometimes conceal the fact that a proof was for the fraudulent, and then you get you get paid for finding that. So that you encourage people to find it because you insure that sometimes there will be some fraudulent proofs that will get paid out, but you hide the fact that they were fraudulent before actually revealing that. So these are some ideas that you can use. The true bit paper has some nice construction that I think we don't have it implemented here, but this is something in our radar, so there's definitely interest for future work there. Thank you very much everyone.
